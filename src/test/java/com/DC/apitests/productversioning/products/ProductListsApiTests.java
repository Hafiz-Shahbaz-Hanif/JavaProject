package com.DC.apitests.productversioning.products;

import com.DC.apitests.productversioning.ApiTestConfig;
import com.DC.db.productVersioning.ProductMasterCollection;
import com.DC.db.productVersioning.ProductVariantListCollection;
import com.DC.testcases.BaseClass;
import com.DC.utilities.apiEngine.apiRequests.productVersioning.ProductListApiRequests;
import com.DC.utilities.apiEngine.apiServices.productversioning.CompanyApiService;
import com.DC.utilities.apiEngine.apiServices.productversioning.ProductListApiService;
import com.DC.utilities.apiEngine.apiServices.productversioning.ProductVersioningApiService;
import com.DC.utilities.apiEngine.models.requests.productVersioning.CreateProductListRequestBody;
import com.DC.utilities.apiEngine.models.responses.productVersioning.*;
import com.DC.utilities.apiEngine.routes.productVersioning.ProductListRoutes;
import com.DC.utilities.enums.Enums;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.restassured.path.json.JsonPath;
import io.restassured.response.Response;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.testng.Assert;
import org.testng.annotations.*;

import java.util.*;
import java.util.stream.Collectors;

import static com.DC.apitests.ApiValidations.*;
import static com.DC.utilities.SecurityAPI.loginAndGetJwt;
import static com.DC.utilities.CommonApiMethods.callEndpoint;
import static java.util.Arrays.asList;

public class ProductListsApiTests extends BaseClass {
    private static final String LIST_NAME_TO_ADD = "QA Automated Product List";
    private static final ApiTestConfig.TestConfig TEST_CONFIG = ApiTestConfig.getTestConfig();
    private static final ProductVariantListCollection PRODUCT_LIST_COLLECTION = new ProductVariantListCollection();
    private static final ProductMasterCollection PRODUCT_MASTER_COLLECTION = new ProductMasterCollection();
    private static Logger logger;
    private static String jwt;
    private static ProductMaster productMaster;
    private static ProductMaster.VariantSets.Live liveVariantToUse;
    private static InstancePathBase instancePath;
    private static InstancePathBase secondInstancePath;
    private static CreateProductListRequestBody listToAdd;

    ProductListsApiTests() {
        logger = Logger.getLogger(ProductListsApiTests.class);
        PropertyConfigurator.configure("log4j.properties");
    }

    @BeforeClass(alwaysRun = true)
    public void setupTests() throws Exception {
        logger.info("Setting up product lists api tests");
        jwt = loginAndGetJwt(TEST_CONFIG.loginEndpoint, TEST_CONFIG.username, TEST_CONFIG.password);
        PRODUCT_LIST_COLLECTION.deleteProductList(LIST_NAME_TO_ADD, TEST_CONFIG.companyID);
        initializeRequiredInfo();
    }

    @AfterClass()
    public void cleanupTests() {
        logger.info("Cleaning up product lists api tests");
        PRODUCT_LIST_COLLECTION.deleteProductList(listToAdd.name, TEST_CONFIG.companyID);
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_Create_Update_AddProducts_Delete() throws Exception {
        var productList = canCreateProductList();
        productList = canUpdateProductList(productList);
        cannotUpdateProductList_DuplicateName(productList);
        cannotUpdateProductList_DuplicateInstances(productList);
        productList = canAddProductInstancesToList(productList);
        cannotAddProductInstanceToList_DuplicateInstances(productList);
        productList = canRemoveProductInstanceFromList(productList);
        canDeleteProductList(productList);
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_CannotCreateProductList_MissingParameters() throws Exception {
        String products = "\"products\": [\n" +
                "        {\n" +
                "            \"productMasterId\": \"23d54002-b39f-4cd1-a66f-cbba32d71620\",\n" +
                "            \"retailerId\": null,\n" +
                "            \"localeId\": \"000f0b1e-f05d-4caa-92c6-08f7ad8cb509\",\n" +
                "            \"campaignId\": null\n" +
                "        }\n" +
                "    ]";

        String bodyWithoutRequiredParameters = "{\n" + products + "\n}";

        Response response = ProductListApiRequests.createProductList(bodyWithoutRequiredParameters, jwt);
        List<String> missingParameters = asList("name", "permission");
        validateMissingRequestParametersError(response, missingParameters);

        bodyWithoutRequiredParameters = "{\n" +
                "    \"name\": \"Autogenerated Test List\",\n" +
                "    \"permission\": \"private\"\n" +
                "}";
        response = ProductListApiRequests.createProductList(bodyWithoutRequiredParameters, jwt);
        String missingParameter = "products";
        validateMissingRequestParametersError(response, missingParameter);

        verifyErrorIsThrownIfProductsObjectDoesNotHaveRequiredParameters("POST");
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_CannotCreateProductList_InvalidParameters() throws Exception {
        verifyErrorIsThrownIfBodyToCreateOrUpdateListHasInvalidData("POST");
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_CannotCreateProductList_DuplicateName() throws Exception {
        var productList = ProductListApiService.getAllCompanyProductLists(jwt).get(0);
        var reBody = new CreateProductListRequestBody(
                productList.name,
                Enums.ProductListPermission.PRIVATE,
                new ArrayList<>()
        );
        Response response = ProductListApiRequests.createProductList(reBody, jwt);
        String expectedError = "List with name " + "\"" + reBody.name + "\" already exists on company with ID " + TEST_CONFIG.companyID;
        validateUnprocessableEntityError(response, expectedError);
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_CannotCreateProductList_DuplicateInstances() throws Exception {
        CreateProductListRequestBody listWithDuplicateInstances = new CreateProductListRequestBody(
                "Automated List",
                Enums.ProductListPermission.PUBLIC,
                asList(instancePath, instancePath)
        );

        String expectedError = generateExpectedErrorMessageForDuplicateInstances(instancePath);
        Response response = ProductListApiRequests.createProductList(listWithDuplicateInstances, jwt);
        validateUnprocessableEntityError(response, expectedError);
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_CannotUpdateProductList_MissingParameters() throws Exception {
        verifyErrorIsThrownIfProductsObjectDoesNotHaveRequiredParameters("PATCH");
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_CannotUpdateProductList_InvalidParameters() throws Exception {
        verifyErrorIsThrownIfBodyToCreateOrUpdateListHasInvalidData("PATCH");
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_CannotUpdateProductList_NonExistentList() throws Exception {
        String randomListId = UUID.randomUUID().toString();
        Response response = ProductListApiRequests.updateProductList(listToAdd, randomListId, jwt);
        String expectedError = "List with id " + "\"" + randomListId + "\" does not exist on company with ID " + TEST_CONFIG.companyID;
        validateUnprocessableEntityError(response, expectedError);
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_CannotAddProductInstanceToList_MissingParameters() throws Exception {
        var productList = ProductListApiService.getAllCompanyProductLists(jwt).get(0);

        String bodyWithoutRequiredParameters = "{\n" +
                "    \"products\": [\n" +
                "        {\n" +
                "            \n" +
                "        }\n" +
                "    ]\n" +
                "}";

        Response response = ProductListApiRequests.addProductInstancesToList(bodyWithoutRequiredParameters, productList._id, jwt);
        List<String> missingParameters = asList("productMasterId", "localeId", "retailerId", "campaignId");
        validateMissingRequestParametersError(response, missingParameters);
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_CannotAddProductInstanceToList_InvalidParameters() throws Exception {
        var productList = ProductListApiService.getAllCompanyProductLists(jwt).get(0);

        String bodyWithInvalidParameters = "{\n" +
                "    \"products\": [\n" +
                "        {\n" +
                "            \"productMasterId\": \"invalid\",\n" +
                "            \"retailerId\": false,\n" +
                "            \"localeId\": \"123\",\n" +
                "            \"campaignId\": 123\n" +
                "        }\n" +
                "    ]\n" +
                "}";


        Response response = ProductListApiRequests.addProductInstancesToList(bodyWithInvalidParameters, productList._id, jwt);
        List<String> expectedErrors = generateExpectedErrorsForInvalidProductData();
        validateInvalidRequestParametersError(response, expectedErrors);
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_CannotAddProductInstanceToList_NonExistentList() throws Exception {
        String randomListId = UUID.randomUUID().toString();
        Response response = ProductListApiRequests.addProductInstancesToList(Collections.singletonList(instancePath), randomListId, jwt);
        String expectedError = "List with ID " + "\"" + randomListId + "\" does not exist on company with ID " + TEST_CONFIG.companyID;
        validateUnprocessableEntityError(response, expectedError);
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_CannotRemoveProductInstanceFromList_InvalidParameters() throws Exception {
        var productList = ProductListApiService.getAllCompanyProductLists(jwt).get(0);

        String bodyWithInvalidParameters = "{\n" +
                "    \"instanceIds\": [123,123]\n" +
                "    \n" +
                "}";

        Response response = callEndpoint(ProductListRoutes.getRemoveProductsFromListRoutePath(productList._id), jwt, "PATCH", bodyWithInvalidParameters, "");
        List<String> expectedErrors = new ArrayList<>();
        expectedErrors.add("\"0\" needs to be a mongo Binary object");
        expectedErrors.add("\"1\" needs to be a mongo Binary object");
        validateInvalidRequestParametersError(response, expectedErrors);
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_CannotRemoveProductInstanceFromList_NonExistentList() throws Exception {
        String randomUUID = UUID.randomUUID().toString();
        Response response = ProductListApiRequests.removeProductsFromList(Collections.singletonList(randomUUID), randomUUID, jwt);
        String expectedError = "List with ID " + "\"" + randomUUID + "\" does not exist on company with ID " + TEST_CONFIG.companyID;
        validateUnprocessableEntityError(response, expectedError);
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_CanGetProductList() throws Exception {
        var productListToGet = ProductListApiService.getAllCompanyProductLists(jwt).get(0);

        Response response = ProductListApiRequests.getProductList(productListToGet._id, jwt);

        FriendlyProductVariantList productListReturned = verifyEndpointReturnsCorrectObject(response, testMethodName.get(), FriendlyProductVariantList.class);

        Assert.assertEquals(productListReturned, productListToGet, "Product list returned doesn't match with the expected list");
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_CannotGetProductList_NonExistentList() throws Exception {
        String randomListId = UUID.randomUUID().toString();
        Response response = ProductListApiRequests.getProductList(randomListId, jwt);
        String expectedError = "List with ID " + randomListId + " does not exist on company with ID " + TEST_CONFIG.companyID;
        validateUnprocessableEntityError(response, expectedError);
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"}, priority = -1)
    public void Api_ProductLists_CanGetAllProductListsInCompany() throws Exception {
        List<String> expectedIds = PRODUCT_LIST_COLLECTION.getAllProductListsInCompany(TEST_CONFIG.companyID)
                .stream()
                .map(list -> list._id)
                .collect(Collectors.toList());

        Response response = ProductListApiRequests.getAllCompanyProductLists(jwt);

        int statusCode = response.getStatusCode();
        checkResponseStatus(testMethodName.get(), "200", statusCode);

        String responseBody = response.getBody().asString();
        List<FriendlyProductVariantList> productListsReturned = null;
        try {
            TypeReference<List<FriendlyProductVariantList>> productVariantListType = new TypeReference<>() {
            };
            productListsReturned = new ObjectMapper().findAndRegisterModules().readValue(responseBody, productVariantListType);
        } catch (Exception e) {
            logger.error("Test: " + testMethodName.get() + " failed. Unable to deserialize response body\n" + e.getMessage());
            Assert.fail("Test: " + testMethodName.get() + " failed. Unable to deserialize response body\n" + e.getMessage());
        }

        List<String> returnedIds = productListsReturned.stream()
                .map(list -> list._id)
                .collect(Collectors.toList());
        Assert.assertEqualsNoOrder(
                new List[]{returnedIds},
                new List[]{expectedIds},
                "Returned product list ids don't match with the ids stored in database"
        );
    }

    @Test(groups = {"ProductListsApiTests", "NoDataProvider"})
    public void Api_ProductLists_CannotDeleteAProductList_NonExistentList() throws Exception {
        String randomListId = UUID.randomUUID().toString();
        Response response = ProductListApiRequests.getProductList(randomListId, jwt);
        String expectedError = "List with ID " + randomListId + " does not exist on company with ID " + TEST_CONFIG.companyID;
        validateUnprocessableEntityError(response, expectedError);
    }

    private void initializeRequiredInfo() throws Exception {
        productMaster = PRODUCT_MASTER_COLLECTION.getProductMaster("QA-STATIC-PRODUCT-001", TEST_CONFIG.companyID);

        String frLocaleId = CompanyApiService.getCompany(jwt).getLocaleId("es-MX");

        liveVariantToUse = productMaster.variantSets.live
                .stream()
                .filter(locale -> locale.localeId.equals(frLocaleId))
                .findFirst()
                .orElseThrow(NoSuchElementException::new);

        instancePath = new InstancePathBase(productMaster._id, liveVariantToUse.localeId, null, null);
        secondInstancePath = new InstancePathBase(productMaster._id, liveVariantToUse.localeId, liveVariantToUse.instances.retailer.get(0).retailerId, null);

        listToAdd = new CreateProductListRequestBody(
                LIST_NAME_TO_ADD,
                Enums.ProductListPermission.PRIVATE,
                asList(instancePath, secondInstancePath)
        );
    }

    private List<ProductVariantListProduct> getExpectedInstancesInList(List<InstancePathBase> instancePaths) throws Exception {
        List<ProductVariantListProduct> expectedInstancesInList = new ArrayList<>();

        for (InstancePathBase instancePath : instancePaths) {
            ProductMasterInstanceComposition instance = ProductVersioningApiService.getProductInstanceComposition(instancePath, jwt);
            ProductMasterInfo masterInfo = instance.productMasterInfo;
            ProductVariantListProduct expectedInstanceInList = new ProductVariantListProduct(masterInfo, instance.masterUniqueId, masterInfo.liveInstanceId);
            expectedInstancesInList.add(expectedInstanceInList);
        }

        return expectedInstancesInList;
    }

    private String generateExpectedErrorMessageForDuplicateInstances(InstancePathBase instancePath) throws Exception {
        ProductMasterInfo instanceComposition = ProductVersioningApiService.getProductInstanceComposed(instancePath, jwt).productMasterInfo;
        String innerMsg = "{\"productMasterId\":\"" + instanceComposition.productMasterId + "\",\"instanceId\":\"" + instanceComposition.liveInstanceId + "\"}";
        return "Duplicate product instances detected: [" + innerMsg + "," + innerMsg + "]";
    }

    private List<String> generateExpectedErrorsForInvalidProductData() {
        List<String> expectedErrors = new ArrayList<>();
        expectedErrors.add("\"productMasterId\" needs to be a mongo Binary object");
        expectedErrors.add("\"localeId\" needs to be a mongo Binary object");
        expectedErrors.add("\"retailerId\" needs to be a mongo Binary object");
        expectedErrors.add("\"campaignId\" needs to be a mongo Binary object");
        return expectedErrors;
    }

    private Response getResponse(String httpMethod, String bodyWithInvalidParameters) throws Exception {
        Response response;
        if (Objects.equals(httpMethod, "PATCH")) {
            response = callEndpoint(
                    ProductListRoutes.getProductListRoutePath(UUID.randomUUID().toString()),
                    jwt,
                    httpMethod,
                    bodyWithInvalidParameters,
                    ""
            );
        } else if (Objects.equals(httpMethod, "POST")) {
            response = callEndpoint(ProductListRoutes.getProductListHost(), jwt, httpMethod, bodyWithInvalidParameters, "");
        } else {
            throw new Exception(httpMethod + " is not supported for this function");
        }
        return response;
    }

    private void verifyErrorIsThrownIfProductsObjectDoesNotHaveRequiredParameters(String httpMethod) throws Exception {
        String bodyWithoutRequiredParameters = "{\n" +
                "    \"name\": \"Autogenerated Test List\",\n" +
                "    \"permission\": \"private\",\n" +
                "    \"products\": [\n" +
                "        {\n" +
                "            \n" +
                "        }\n" +
                "    ]\n" +
                "}";
        Response response = getResponse(httpMethod, bodyWithoutRequiredParameters);
        List<String> missingParameters = asList("productMasterId", "localeId", "retailerId", "campaignId");
        validateMissingRequestParametersError(response, missingParameters);
    }

    private void verifyErrorIsThrownIfBodyToCreateOrUpdateListHasInvalidData(String httpMethod) throws Exception {
        String bodyWithInvalidParameters = "{\n" +
                "    \"name\": null,\n" +
                "    \"permission\": \"invalid\",\n" +
                "    \"products\": [\n" +
                "        {\n" +
                "            \"productMasterId\": \"this is not a binary\",\n" +
                "            \"retailerId\": 123,\n" +
                "            \"localeId\": false,\n" +
                "            \"campaignId\": \"12345\"\n" +
                "        }\n" +
                "    ]\n" +
                "}";

        Response response = getResponse(httpMethod, bodyWithInvalidParameters);

        List<String> expectedErrors = new ArrayList<>();
        expectedErrors.add("\"name\" must be a string");
        expectedErrors.add("\"permission\" must be one of [private, public]");
        expectedErrors.addAll(generateExpectedErrorsForInvalidProductData());
        validateInvalidRequestParametersError(response, expectedErrors);
    }

    public FriendlyProductVariantList canCreateProductList() throws Exception {
        PRODUCT_LIST_COLLECTION.deleteProductList(listToAdd.name, TEST_CONFIG.companyID);

        Response response = ProductListApiRequests.createProductList(listToAdd, jwt);
        FriendlyProductVariantList productListCreated = verifyEndpointReturnsCorrectObject(response, testMethodName.get(), FriendlyProductVariantList.class);

        Assert.assertNotNull(productListCreated._id, "Id of list was null");
        Assert.assertEquals(productListCreated._version, 1, "Version of list doesn't match with the expected version");
        Assert.assertEquals(productListCreated.name, listToAdd.name, "List name doesn't match with the expected name");
        Assert.assertNotNull(productListCreated.dateCreated, "DateCreated value was null on list created");
        Assert.assertEquals(productListCreated.dateUpdated, productListCreated.dateCreated, "DateUpdated value doesn't match with the dateCreated value");
        Assert.assertEquals(productListCreated.companyId, TEST_CONFIG.companyID, "List was not create in expected company");
        Assert.assertNotNull(productListCreated.ownerId, "OwnerId was null");
        Assert.assertNotNull(productListCreated.ownerName, "Owner name was null");
        Assert.assertEquals(productListCreated.permission, listToAdd.permission, "Permission doesn't match with the expected value");

        List<ProductVariantListProduct> expectedInstancesInList = getExpectedInstancesInList(listToAdd.products);
        Assert.assertEquals(productListCreated.products, expectedInstancesInList, "Products in list don't match with expected products");
        return productListCreated;
    }

    public FriendlyProductVariantList canUpdateProductList(FriendlyProductVariantList productListBefore) throws Exception {
        ProductMaster productMaster = PRODUCT_MASTER_COLLECTION.getProductMaster("QA-STATIC-PRODUCT-002", TEST_CONFIG.companyID);
        ProductMaster.VariantSets.Live liveVariantToUse = productMaster.variantSets.live.get(0);
        InstancePathBase instancePath = new InstancePathBase(productMaster._id, liveVariantToUse.localeId, null, null);

        CreateProductListRequestBody listWithUpdates = new CreateProductListRequestBody(
                productListBefore.name + "-NEW",
                listToAdd.permission,
                Collections.singletonList(instancePath)
        );

        Response response = ProductListApiRequests.updateProductList(listWithUpdates, productListBefore._id, jwt);

        FriendlyProductVariantList productListUpdated = verifyEndpointReturnsCorrectObject(response, testMethodName.get(), FriendlyProductVariantList.class);

        Assert.assertEquals(productListUpdated._id, productListBefore._id, "Id of list changed after updating list");
        Assert.assertEquals(
                productListUpdated._version,
                productListBefore._version + 1,
                "Version of list doesn't match with expected version after updating list");
        Assert.assertEquals(productListUpdated.name, listWithUpdates.name, "List name was not updated");

        listToAdd.name = listWithUpdates.name;

        Assert.assertEquals(productListUpdated.dateCreated, productListBefore.dateCreated, "DateCreated value changed after updating list");
        Assert.assertNotEquals(productListUpdated.dateUpdated, productListBefore.dateCreated, "DateUpdated value was not updated");
        Assert.assertEquals(productListUpdated.ownerId, productListBefore.ownerId, "OwnerId changed after updating list");
        Assert.assertEquals(productListUpdated.permission, productListBefore.permission, "Permission changed after updating list");

        List<ProductVariantListProduct> expectedInstancesInList = getExpectedInstancesInList(listWithUpdates.products);
        Assert.assertEquals(productListUpdated.products, expectedInstancesInList, "Products don't match with the expected products");
        return productListUpdated;
    }

    public void cannotUpdateProductList_DuplicateName(FriendlyProductVariantList productList) throws Exception {
        CreateProductListRequestBody listWithDuplicateName = new CreateProductListRequestBody(
                "Static List For Automated API Tests",
                listToAdd.permission,
                new ArrayList<>()
        );

        Response response = ProductListApiRequests.updateProductList(listWithDuplicateName, productList._id, jwt);
        String expectedError = "List with name " + "\"" + listWithDuplicateName.name + "\" already exists on company with ID " + productList.companyId;
        validateUnprocessableEntityError(response, expectedError);
    }

    public void cannotUpdateProductList_DuplicateInstances(FriendlyProductVariantList productList) throws Exception {
        InstancePathBase instancePathBase = productList.products.get(0).getInstancePathBase();

        CreateProductListRequestBody listWithDuplicateInstances = new CreateProductListRequestBody(
                productList.name,
                productList.permission,
                asList(instancePathBase, instancePathBase)
        );

        String expectedError = generateExpectedErrorMessageForDuplicateInstances(instancePathBase);
        Response response = ProductListApiRequests.updateProductList(listWithDuplicateInstances, productList._id, jwt);
        validateUnprocessableEntityError(response, expectedError);
    }

    public FriendlyProductVariantList canAddProductInstancesToList(FriendlyProductVariantList productListBefore) throws Exception {
        InstancePathBase instancePath = new InstancePathBase(
                productMaster._id,
                liveVariantToUse.localeId,
                null,
                liveVariantToUse.instances.globalCampaign.get(0).campaignId
        );

        InstancePathBase instancePath2 = new InstancePathBase(
                productMaster._id,
                liveVariantToUse.localeId,
                liveVariantToUse.instances.retailerCampaign.get(0).retailerId,
                liveVariantToUse.instances.retailerCampaign.get(0).campaignId
        );

        List<InstancePathBase> instancesToAdd = asList(instancePath, instancePath2);
        Response response = ProductListApiRequests.addProductInstancesToList(instancesToAdd, productListBefore._id, jwt);

        FriendlyProductVariantList productListReturned = verifyEndpointReturnsCorrectObject(response, testMethodName.get(), FriendlyProductVariantList.class);

        Assert.assertEquals(productListReturned._id, productListBefore._id, "Id of list changed after adding products to it");
        Assert.assertEquals(
                productListReturned._version,
                productListBefore._version + 1,
                "Version of list doesn't match with expected version after adding products to it");
        Assert.assertEquals(productListReturned.name, productListBefore.name, "List name changed after adding products to it");
        Assert.assertEquals(productListReturned.dateCreated, productListBefore.dateCreated, "DateCreated value changed after adding products to list");
        Assert.assertNotEquals(productListReturned.dateUpdated, productListBefore.dateCreated, "DateUpdated value was not updated");
        Assert.assertEquals(productListReturned.ownerId, productListBefore.ownerId, "OwnerId changed after adding products to list");
        Assert.assertEquals(productListReturned.permission, productListBefore.permission, "Permission changed after adding products to list");

        List<ProductVariantListProduct> expectedProducts = productListBefore.products;
        expectedProducts.addAll(getExpectedInstancesInList(instancesToAdd));

        Assert.assertEqualsNoOrder(
                productListReturned.products.toArray(),
                expectedProducts.toArray(),
                "Products in list doesn't match with the expected products" +
                        "\nProducts returned:\n" + new ObjectMapper().writeValueAsString(productListReturned.products) +
                        "\nExpected products:\n" +
                        new ObjectMapper().writeValueAsString(productListReturned.products)
        );

        return productListReturned;
    }

    public void cannotAddProductInstanceToList_DuplicateInstances(FriendlyProductVariantList productList) throws Exception {
        InstancePathBase instancePath = productList.products.get(0).getInstancePathBase();

        String expectedError = generateExpectedErrorMessageForDuplicateInstances(instancePath);
        Response response = ProductListApiRequests.addProductInstancesToList(Collections.singletonList(instancePath), productList._id, jwt);
        validateUnprocessableEntityError(response, expectedError);
    }

    public FriendlyProductVariantList canRemoveProductInstanceFromList(FriendlyProductVariantList productListBefore) throws Exception {
        InstancePathBase instancePath = new InstancePathBase(
                productMaster._id,
                liveVariantToUse.localeId,
                null,
                null
        );

        InstancePathBase instancePath2 = new InstancePathBase(
                productMaster._id,
                liveVariantToUse.localeId,
                liveVariantToUse.instances.retailer.get(0).retailerId,
                null
        );

        InstancePathBase instancePath3 = new InstancePathBase(
                productMaster._id,
                liveVariantToUse.localeId,
                null,
                liveVariantToUse.instances.globalCampaign.get(0).campaignId
        );

        InstancePathBase instancePath4 = new InstancePathBase(
                productMaster._id,
                liveVariantToUse.localeId,
                liveVariantToUse.instances.retailerCampaign.get(0).retailerId,
                liveVariantToUse.instances.retailerCampaign.get(0).campaignId
        );

        List<InstancePathBase> instancesToAdd = asList(instancePath, instancePath2, instancePath3, instancePath4);

        CreateProductListRequestBody list = new CreateProductListRequestBody(
                productListBefore.name,
                listToAdd.permission,
                instancesToAdd
        );

        var productList = ProductListApiService.updateProductList(list, productListBefore._id, jwt);

        List<String> instanceIdsToRemove = asList(
                productList.products.get(0).instanceId,
                productList.products.get(productList.products.size() - 1).instanceId
        );

        Response response = ProductListApiRequests.removeProductsFromList(instanceIdsToRemove, productList._id, jwt);

        FriendlyProductVariantList productListReturned = verifyEndpointReturnsCorrectObject(response, testMethodName.get(), FriendlyProductVariantList.class);

        Assert.assertEquals(productListReturned._id, productList._id, "Id of list changed after removing products from it");
        Assert.assertEquals(
                productListReturned._version,
                productList._version + 1,
                "Version of list doesn't match with expected version after removing products from it");
        Assert.assertEquals(productListReturned.name, productList.name, "List name changed after removing products from it");
        Assert.assertEquals(productListReturned.dateCreated, productList.dateCreated, "DateCreated value changed after removing products from list");
        Assert.assertNotEquals(productListReturned.dateUpdated, productList.dateCreated, "DateUpdated value was not updated");
        Assert.assertEquals(productListReturned.ownerId, productList.ownerId, "OwnerId changed after removing products from list");
        Assert.assertEquals(productListReturned.permission, productList.permission, "Permission changed after removing products from list");

        Assert.assertEquals(
                productListReturned.products.size(),
                productList.products.size() - instanceIdsToRemove.size(),
                "Returned product count doesn't match with the expected count"
        );
        boolean productsWereRemoved = productListReturned.products.
                stream()
                .noneMatch(prod -> instanceIdsToRemove.contains(prod.instanceId));
        Assert.assertTrue(productsWereRemoved,
                "Products were not removed from list\n" +
                        "Products returned: " + productListReturned.products +
                        "Instances to remove: " + String.join("\n", instanceIdsToRemove)
        );
        return productListReturned;
    }

    public void canDeleteProductList(FriendlyProductVariantList productList) throws Exception {
        Response response = ProductListApiRequests.deleteProductList(productList._id, jwt);

        ProductVariantList productListDeleted = verifyEndpointReturnsCorrectObject(response, testMethodName.get(), FriendlyProductVariantList.class);

        Assert.assertEquals(productListDeleted._id, productList._id, "Removed list id doesn't match with expected list id");

        response = ProductListApiRequests.getProductList(productList._id, jwt);
        String expectedError = "List with ID " + productList._id + " does not exist on company with ID " + TEST_CONFIG.companyID;
        JsonPath jsonPathEvaluator = response.getBody().jsonPath();
        int statusCode = response.getStatusCode();
        String message = jsonPathEvaluator.getString("message");
        Assert.assertNotEquals(statusCode, 200, "List was not removed from company");
        Assert.assertEquals(message, expectedError);
    }
}
