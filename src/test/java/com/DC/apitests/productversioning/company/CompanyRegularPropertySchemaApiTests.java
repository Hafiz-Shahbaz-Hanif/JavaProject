package com.DC.apitests.productversioning.company;

import com.DC.db.productVersioning.CompanyPropertiesCollection;
import com.DC.utilities.apiEngine.apiRequests.productVersioning.CompanyApiRequests;
import com.DC.utilities.apiEngine.apiServices.productversioning.CompanyApiService;
import com.DC.utilities.apiEngine.apiServices.productversioning.ProductVersioningApiService;
import com.DC.utilities.apiEngine.models.requests.productVersioning.CompanyDigitalAssetsCreate;
import com.DC.utilities.apiEngine.models.requests.productVersioning.CreateProductMasterRequestBody;
import com.DC.utilities.apiEngine.models.requests.productVersioning.ProductVariantPropertySetRequestBody;
import com.DC.utilities.apiEngine.models.responses.productVersioning.*;
import com.DC.utilities.enums.Enums;
import io.restassured.response.Response;
import org.testng.Assert;
import org.testng.annotations.Test;

import java.util.Collections;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static com.DC.apitests.ApiValidations.*;
import static java.util.Arrays.asList;

public class CompanyRegularPropertySchemaApiTests extends CompanyPropertiesApiBaseClass {

    @Test(groups = {"CompanyApiTests", "NoDataProvider"})
    public void Api_Company_CanUpdateExistingCompanyProperty() throws Exception {
        Company company = createCompanyIfNeeded(FULL_COMPANY_TO_ADD);

        CompanyProperties companyProperties = new CompanyPropertiesCollection().getCompanyProperties(company.companyPropertiesId);

        String idOfPropertyToUpdate = "autogenerated_property";
        CompanyProperties.Property originalProperty = createCompanyPropertiesReqBody.propertySchema.stream().filter(property -> property.id.equals(idOfPropertyToUpdate)).findFirst().orElseThrow(java.util.NoSuchElementException::new);

        CompanyProperties.Property propertyToUpdate = new CompanyProperties.Property();
        propertyToUpdate.id = originalProperty.id;
        propertyToUpdate.name = originalProperty.name;
        propertyToUpdate.type = originalProperty.type;
        propertyToUpdate.helpText = originalProperty.helpText;
        propertyToUpdate.allowMultipleValues = originalProperty.allowMultipleValues;
        propertyToUpdate.dropdownValues = originalProperty.dropdownValues;
        propertyToUpdate.group = Objects.equals(originalProperty.group, "Group 1") ? "Group 2" : "Group 1";

        Response response = CompanyApiRequests.updateExistingRegularCompanyProperties(Collections.singletonList(propertyToUpdate), jwt);
        CompanyProperties returnedCompanyProperties = verifyEndpointReturnsCorrectObject(response, testMethodName.get(), CompanyProperties.class);

        // CHECK PROPERTY GROUP
        CompanyProperties.Group originalGroupBeforeUpdate = companyProperties.groups.stream().filter(group -> group.name.equals(originalProperty.group)).findFirst().orElse(null);

        CompanyProperties.Group originalGroupAfterUpdate = returnedCompanyProperties.groups.stream().filter(group -> group.name.equals(originalProperty.group)).findFirst().orElse(null);

        verifyPropertyWasRemovedFromGroup(originalProperty, originalGroupAfterUpdate, originalGroupBeforeUpdate);

        CompanyProperties.Group secondaryGroupBeforeUpdate = companyProperties.groups.stream().filter(group -> group.name.equals(propertyToUpdate.group)).findFirst().orElse(null);

        CompanyProperties.Group secondaryGroupAfterUpdate = returnedCompanyProperties.groups.stream().filter(group -> group.name.equals(propertyToUpdate.group)).findFirst().orElse(null);

        Assert.assertNotEquals(secondaryGroupAfterUpdate, secondaryGroupBeforeUpdate, "Secondary group was not updated with updated property");

        int propertyToUpdateIndexInSecondaryGroup = IntStream.range(0, secondaryGroupAfterUpdate.properties.size()).filter(i -> Objects.equals(secondaryGroupAfterUpdate.properties.get(i).id, originalProperty.id)).findFirst().orElse(-1);

        Assert.assertNotEquals(propertyToUpdateIndexInSecondaryGroup, -1, "Property " + propertyToUpdate.id + " was not moved to group" + propertyToUpdate.group);
        Assert.assertEquals(propertyToUpdateIndexInSecondaryGroup, secondaryGroupAfterUpdate.properties.size() - 1, "SortIndex of property didn't match with the expected index");
    }

    @Test(groups = {"CompanyApiTests", "NoDataProvider"})
    public void Api_Company_CrossSiteScriptingTest() throws Exception {
        Company company = createCompanyIfNeeded(FULL_COMPANY_TO_ADD);
        CompanyPropertiesBase.Property testProperty = new CompanyPropertiesBase.Property();

        testProperty.id = "test_scripting_property";
        testProperty.name = "Test Scripting property";
        testProperty.type = Enums.PropertyType.HTML;
        testProperty.helpText = null;
        testProperty.allowMultipleValues = false;
        testProperty.group = null;

        String localeId = company.locales.get(0).localeId;

        CompanyApiService.mergeRegularPropertiesToPropertySchema(Collections.singletonList(testProperty), jwt);

        CreateProductMasterRequestBody scriptingTestProduct = new CreateProductMasterRequestBody("QA_Scripting-Test", "QA Scripting Test 1", null);

        ProductVersioningApiService.deleteProductMasterByUniqueId(scriptingTestProduct.uniqueId, jwt);
        ProductMaster productMaster = ProductVersioningApiService.createProductMaster(scriptingTestProduct, jwt);

        //create product variant live
        productMaster = ProductVersioningApiService.createProductVariant(productMaster._id, localeId, jwt);

        //merge variant properties
        ProductVariantProperty variantProperty = new ProductVariantProperty(testProperty.id, Collections.singletonList("<img src=a onerror=alert(document.cookie)>"));

        ProductVariantPropertySetRequestBody propertySetToAdd = new ProductVariantPropertySetRequestBody(Enums.ProductVariantLevel.GLOBAL.getLevel(), localeId, null, null, Collections.singletonList(variantProperty));

        ProductVersioningApiService.addPropertiesToVariantPropertySet(propertySetToAdd, productMaster._id, jwt);

        //update company property
        CompanyProperties.Property propertyToUpdate = new CompanyProperties.Property();
        propertyToUpdate.id = testProperty.id;
        propertyToUpdate.name = testProperty.name;
        propertyToUpdate.type = Enums.PropertyType.STRING;
        propertyToUpdate.helpText = testProperty.helpText;
        propertyToUpdate.allowMultipleValues = testProperty.allowMultipleValues;
        propertyToUpdate.dropdownValues = testProperty.dropdownValues;
        propertyToUpdate.group = testProperty.group;

        CompanyProperties companyProperties = CompanyApiService.updateExistingRegularCompanyProperties(Collections.singletonList(propertyToUpdate), jwt);
        CompanyPropertiesBase.Property property = companyProperties.propertySchema.stream().filter(p -> p.id.equals(propertyToUpdate.id)).findFirst().orElseThrow(NoSuchElementException::new);

        //Get the property
        ProductVariantInstancePath instancePath = new ProductVariantInstancePath(productMaster._id, localeId, Enums.ProductVariantType.LIVE, null, null);
        ProductVariantPropertySet propertySet = ProductVersioningApiService.getPropertySetData(instancePath, null, jwt);
        Assert.assertEquals(propertySet.properties.get(0).values.get(0), "<img src>","Property values are not updated");
        Assert.assertEquals(property.type, propertyToUpdate.type, "Property types not updated");
    }

    @Test(groups = {"CompanyApiTests", "NoDataProvider"})
    public void Api_Company_CanDeletePropertyFromCompany() throws Exception {
        Company company = setupCompanyForTest(FULL_COMPANY_TO_ADD);
        CompanyPropertiesBase companyProperties = CompanyApiService.getCompanyWithProperties(jwt).companyProperties;

        Company.CompanyLocales companyLocaleToUse = company.locales.get(0);
        Company.CompanyRetailers companyRetailerToUse = company.retailers.get(0);

        ProductMaster productMaster = createProductAndVariantIfNeeded(jwt, company._id, companyLocaleToUse.localeId);

        String idOfPropertyToRemove = "autogenerated_property_4";
        CompanyProperties.Property propertyToRemove = createCompanyPropertiesReqBody.propertySchema.stream().filter(property -> property.id.equals(idOfPropertyToRemove)).findFirst().orElseThrow(java.util.NoSuchElementException::new);

        ProductVariantProperty firstProperty = new ProductVariantProperty(propertyToRemove.id, Collections.singletonList("this is a string"));
        ProductVariantProperty secondProperty = new ProductVariantProperty("autogenerated_property_3", Collections.singletonList(123));

        ProductVariantPropertySetRequestBody propertySetToAdd = new ProductVariantPropertySetRequestBody(Enums.ProductVariantLevel.RETAILER.getLevel(), companyLocaleToUse.localeId, companyRetailerToUse.systemRetailerId, null, asList(firstProperty, secondProperty));

        ProductVariantPropertySet variantPropertySetBefore = ProductVersioningApiService.replaceVariantPropertySet(propertySetToAdd, productMaster._id, jwt);

        Response response = CompanyApiRequests.deleteRegularPropertiesFromCompany(Collections.singletonList(propertyToRemove.id), jwt);
        CompanyProperties returnedCompanyProperties = verifyEndpointReturnsCorrectObject(response, testMethodName.get(), CompanyProperties.class);

        Assert.assertNotEquals(returnedCompanyProperties, companyProperties, "Company property schema didn't change after removing property from company");

        companyProperties.propertySchema.remove(propertyToRemove);
        Assert.assertEquals(returnedCompanyProperties.propertySchema, companyProperties.propertySchema, "Returned property schema didn't match with the expected company schema");

        company = COMPANY_COLLECTION.getCompany(company._id);

        Assert.assertEquals(returnedCompanyProperties._id, company.companyPropertiesId, "CompanyPropertiesId didn't change after removing property from company");

        // CHECK PROPERTY GROUP
        CompanyProperties.Group expectedGroup = companyProperties.groups.stream().filter(group -> group.name.equals(propertyToRemove.group)).findFirst().orElse(null);

        CompanyProperties.Group groupAfterRemovingProperty = returnedCompanyProperties.groups.stream().filter(group -> group.name.equals(propertyToRemove.group)).findFirst().orElse(null);

        verifyPropertyWasRemovedFromGroup(propertyToRemove, groupAfterRemovingProperty, expectedGroup);

        productMaster = ProductVersioningApiService.getProductMaster(productMaster._id, jwt);

        ProductVariantInstancePath instancePath = new ProductVariantInstancePath(productMaster._id, companyLocaleToUse.localeId, Enums.ProductVariantType.LIVE, companyRetailerToUse.systemRetailerId, null);

        String errorMessageToShow = "Variant property set didn't change after removing property from company";
        ProductVariantPropertySet propertySetAfter = waitForPropertySetToChange(instancePath, variantPropertySetBefore, errorMessageToShow);
        Assert.assertFalse(propertySetAfter.properties.contains(firstProperty), "Property was not removed from product after removing it from company");
    }

    @Test(groups = {"CompanyApiTests", "NoDataProvider"})
    public void Api_Company_CannotDeletePropertyFromCompany_InvalidParameters() throws Exception {
        String reqBody = "{\n" + "    \"propertyIds\": [\"automated\", 12345]\n" + "}";

        Response response = CompanyApiRequests.deleteRegularPropertiesFromCompany(reqBody, jwt);
        List<String> expectedErrors = Collections.singletonList("\"1\" must be a string");
        validateInvalidRequestParametersError(response, expectedErrors);
    }

    @Test(groups = {"CompanyApiTests", "NoDataProvider"})
    public void Api_Company_CannotDeleteAssociatedMappingPropertiesIfTheyAreAttachedToADefinition() throws Exception {
        setupCompanyForTest(FULL_COMPANY_TO_ADD);

        // Choosing a property that has addImageMappingSpecs set to true
        List<String> idsOfPropertiesToRemove = asList("digital_asset_property_mapping", "digital_asset_property_3_mapping");

        Response response = CompanyApiRequests.deleteRegularPropertiesFromCompany(idsOfPropertiesToRemove, jwt);
        String expectedError = "Cannot delete properties because they are part of digital asset image spec mappings: " + String.join(",", idsOfPropertiesToRemove);
        validateUnprocessableEntityError(response, expectedError);

        // Check properties were not removed from the company
        List<CompanyPropertiesBase.Property> companyProperties = CompanyApiService.getCompanyWithProperties(jwt).companyProperties.propertySchema;

        for (String idOfPropertyToRemove : idsOfPropertiesToRemove) {
            Assert.assertTrue(companyProperties.stream().anyMatch(prop -> prop.id.equals(idOfPropertyToRemove)), "Property " + idOfPropertyToRemove + " was removed from company even though it was attached to a definition");
        }
    }

    @Test(groups = {"CompanyApiTests", "NoDataProvider"})
    public void Api_Company_CannotStoreDigitalAssetsOnRegularPropertySchema() throws Exception {
        setupCompanyForTest(FULL_COMPANY_TO_ADD);

        CompanyDigitalAssetsCreate digitalAssetProperty = new CompanyDigitalAssetsCreate();
        digitalAssetProperty.id = "digital_asset_in_regular_property_schema";
        digitalAssetProperty.name = "Digital Asset in regular property schema";
        digitalAssetProperty.type = Enums.PropertyType.DIGITAL_ASSET;
        digitalAssetProperty.helpText = null;
        digitalAssetProperty.allowMultipleValues = true;
        digitalAssetProperty.dropdownValues = null;
        digitalAssetProperty.group = null;

        String expectedErrorMessage = "No properties in the property schema can be of type [digital_asset].";
        List<CompanyPropertiesBase.Property> digitalAssetProperties = Collections.singletonList(digitalAssetProperty);

        Response response = CompanyApiRequests.replaceRegularPropertySchema(digitalAssetProperties, jwt);
        validateUnprocessableEntityError(response, expectedErrorMessage);

        response = CompanyApiRequests.mergeRegularPropertiesToPropertySchema(digitalAssetProperties, jwt);
        validateUnprocessableEntityError(response, expectedErrorMessage);

        digitalAssetProperty.id = createCompanyPropertiesReqBody.propertySchema.get(0).id;
        digitalAssetProperties = Collections.singletonList(digitalAssetProperty);
        response = CompanyApiRequests.updateExistingRegularCompanyProperties(digitalAssetProperties, jwt);
        validateUnprocessableEntityError(response, expectedErrorMessage);
    }

    @Test(groups = {"CompanyApiTests", "NoDataProvider"})
    public void Api_Company_ImageSpecMappingPropertiesAreNotCreatedForRegularProperties() throws Exception {
        setupCompanyForTest(FULL_COMPANY_TO_ADD);

        // Using the CompanyDigitalAssetsCreate to create regular property that has addImageMappingSpecs set to true
        CompanyDigitalAssetsCreate digitalAssetProperty = new CompanyDigitalAssetsCreate();
        digitalAssetProperty.id = "property_without_image_mapping";
        digitalAssetProperty.name = "Property Without Image Mapping";
        digitalAssetProperty.type = Enums.PropertyType.STRING;
        digitalAssetProperty.helpText = null;
        digitalAssetProperty.allowMultipleValues = true;
        digitalAssetProperty.dropdownValues = null;
        digitalAssetProperty.group = null;
        digitalAssetProperty.addImageMappingSpecs = true;

        List<CompanyPropertiesBase.Property> digitalAssetProperties = Collections.singletonList(digitalAssetProperty);
        List<CompanyPropertiesBase.Property> originalPropertySchema = CompanyApiService.getCompanyWithProperties(jwt).companyProperties.propertySchema;

        Response response = CompanyApiRequests.mergeRegularPropertiesToPropertySchema(digitalAssetProperties, jwt);
        List<CompanyPropertiesBase.Property> propertySchemaAfter = verifyEndpointReturnsCorrectObject(response, testMethodName.get(), CompanyProperties.class).propertySchema;
        verifyImageMappingPropertiesWereNotAdded(propertySchemaAfter, originalPropertySchema, digitalAssetProperty.id);

        response = CompanyApiRequests.updateExistingRegularCompanyProperties(digitalAssetProperties, jwt);
        propertySchemaAfter = verifyEndpointReturnsCorrectObject(response, testMethodName.get(), CompanyProperties.class).propertySchema;
        verifyImageMappingPropertiesWereNotAdded(propertySchemaAfter, originalPropertySchema, digitalAssetProperty.id);

        List<CompanyPropertiesBase.Property> combinedList = Stream.concat(originalPropertySchema.stream(), digitalAssetProperties.stream()).collect(Collectors.toList());
        response = CompanyApiRequests.replaceRegularPropertySchema(combinedList, jwt);
        propertySchemaAfter = verifyEndpointReturnsCorrectObject(response, testMethodName.get(), CompanyProperties.class).propertySchema;
        verifyImageMappingPropertiesWereNotAdded(propertySchemaAfter, originalPropertySchema, digitalAssetProperty.id);
    }

    private static void verifyImageMappingPropertiesWereNotAdded(List<CompanyPropertiesBase.Property> propertySchemaAfter, List<CompanyPropertiesBase.Property> originalPropertySchema, String propertyId) {
        Assert.assertTrue(propertySchemaAfter.stream().anyMatch(prop -> prop.id.equals(propertyId)), "Property " + propertyId + " was not added to the property schema");

        List<String> associatedPropertiesThatShouldNotBeAdded = asList(propertyId + "_mapping", propertyId + "_instructions");

        for (String associatedProperty : associatedPropertiesThatShouldNotBeAdded) {
            Assert.assertFalse(propertySchemaAfter.stream().anyMatch(prop -> prop.id.equals(associatedProperty)), "Image mapping property " + associatedProperty + " was added to the property schema even though it shouldn't have been");
        }
    }
}
